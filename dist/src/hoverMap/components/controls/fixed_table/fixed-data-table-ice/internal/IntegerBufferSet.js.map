{"version":3,"sources":["../../../../../../../../src/hoverMap/components/controls/fixed_table/fixed-data-table-ice/internal/IntegerBufferSet.js"],"names":["Heap","require","invariant","IntegerBufferSet","$IntegerBufferSet_valueToPositionMap","$IntegerBufferSet_size","$IntegerBufferSet_smallValues","$IntegerBufferSet_smallerComparator","$IntegerBufferSet_largeValues","$IntegerBufferSet_greaterComparator","getNewPositionForValue","bind","getValuePosition","getSize","replaceFurthestValuePosition","prototype","value","undefined","newPosition","$IntegerBufferSet_pushToHeaps","lowValue","highValue","newValue","$IntegerBufferSet_cleanHeaps","empty","minValue","peek","maxValue","valueToReplace","pop","position","element","push","$IntegerBufferSet_cleanHeap","minHeapSize","Math","min","size","maxHeapSize","max","$IntegerBufferSet_recreateHeaps","sourceHeap","newSmallValues","newLargeValues","heap","lhs","rhs","module","exports"],"mappings":"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","file":"IntegerBufferSet.js","sourcesContent":["/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule IntegerBufferSet\n * @typechecks\n */\n\n\"use strict\";\n\nvar Heap = require('./Heap');\n\nvar invariant = require('./invariant');\n\n// Data structure that allows to store values and assign positions to them\n// in a way to minimize changing positions of stored values when new ones are\n// added or when some values are replaced. Stored elements are alwasy assigned\n// a consecutive set of positoins startin from 0 up to count of elements less 1\n// Following actions can be executed\n// * get position assigned to given value (null if value is not stored)\n// * create new entry for new value and get assigned position back\n// * replace value that is furthest from specified value range with new value\n//   and get it's position back\n// All operations take amortized log(n) time where n is number of elements in\n// the set.\n\n  function IntegerBufferSet() {\n    this.$IntegerBufferSet_valueToPositionMap = {};\n    this.$IntegerBufferSet_size = 0;\n    this.$IntegerBufferSet_smallValues = new Heap(\n      [], // Initial data in the heap\n      this.$IntegerBufferSet_smallerComparator\n    );\n    this.$IntegerBufferSet_largeValues = new Heap(\n      [], // Initial data in the heap\n      this.$IntegerBufferSet_greaterComparator\n    );\n\n    this.getNewPositionForValue = this.getNewPositionForValue.bind(this);\n    this.getValuePosition = this.getValuePosition.bind(this);\n    this.getSize = this.getSize.bind(this);\n    this.replaceFurthestValuePosition =\n      this.replaceFurthestValuePosition.bind(this);\n  }\n\n  IntegerBufferSet.prototype.getSize=function()  {\n    return this.$IntegerBufferSet_size;\n  };\n\n  IntegerBufferSet.prototype.getValuePosition=function(value)  {\n    if (this.$IntegerBufferSet_valueToPositionMap[value] === undefined) {\n      return null;\n    }\n    return this.$IntegerBufferSet_valueToPositionMap[value];\n  };\n\n  IntegerBufferSet.prototype.getNewPositionForValue=function(value)  {\n    invariant(\n      this.$IntegerBufferSet_valueToPositionMap[value] === undefined,\n      \"Shouldn't try to find new position for value already stored in BufferSet\"\n    );\n    var newPosition = this.$IntegerBufferSet_size;\n    this.$IntegerBufferSet_size++;\n    this.$IntegerBufferSet_pushToHeaps(newPosition, value);\n    this.$IntegerBufferSet_valueToPositionMap[value] = newPosition;\n    return newPosition;\n  };\n\n  IntegerBufferSet.prototype.replaceFurthestValuePosition=function(\nlowValue,\n    /*number*/ highValue,\n    /*number*/ newValue)\n    {\n    invariant(\n      this.$IntegerBufferSet_valueToPositionMap[newValue] === undefined,\n      \"Shouldn't try to replace values with value already stored value in \" +\n      \"BufferSet\"\n    );\n\n    this.$IntegerBufferSet_cleanHeaps();\n    if (this.$IntegerBufferSet_smallValues.empty() || this.$IntegerBufferSet_largeValues.empty()) {\n      // Threre are currently no values stored. We will have to create new\n      // position for this value.\n      return null;\n    }\n\n    var minValue = this.$IntegerBufferSet_smallValues.peek().value;\n    var maxValue = this.$IntegerBufferSet_largeValues.peek().value;\n    if (minValue >= lowValue && maxValue <= highValue) {\n      // All values currently stored are necessary, we can't reuse any of them.\n      return null;\n    }\n\n    var valueToReplace;\n    if (lowValue - minValue > maxValue - highValue) {\n      // minValue is further from provided range. We will reuse it's position.\n      valueToReplace = minValue;\n      this.$IntegerBufferSet_smallValues.pop();\n    } else {\n      valueToReplace = maxValue;\n      this.$IntegerBufferSet_largeValues.pop();\n    }\n    var position = this.$IntegerBufferSet_valueToPositionMap[valueToReplace];\n    delete this.$IntegerBufferSet_valueToPositionMap[valueToReplace];\n    this.$IntegerBufferSet_valueToPositionMap[newValue] = position;\n    this.$IntegerBufferSet_pushToHeaps(position, newValue);\n\n    return position;\n  };\n\n  IntegerBufferSet.prototype.$IntegerBufferSet_pushToHeaps=function(position, /*number*/ value) {\n    var element = {\n      position:position,\n      value:value,\n    };\n    // We can reuse the same object in both heaps, because we don't mutate them\n    this.$IntegerBufferSet_smallValues.push(element);\n    this.$IntegerBufferSet_largeValues.push(element);\n  };\n\n  IntegerBufferSet.prototype.$IntegerBufferSet_cleanHeaps=function() {\n    // We not usually only remove object from one heap while moving value.\n    // Here we make sure that there is no stale data on top of heaps.\n    this.$IntegerBufferSet_cleanHeap(this.$IntegerBufferSet_smallValues);\n    this.$IntegerBufferSet_cleanHeap(this.$IntegerBufferSet_largeValues);\n    var minHeapSize =\n      Math.min(this.$IntegerBufferSet_smallValues.size(), this.$IntegerBufferSet_largeValues.size());\n    var maxHeapSize =\n      Math.max(this.$IntegerBufferSet_smallValues.size(), this.$IntegerBufferSet_largeValues.size());\n    if (maxHeapSize > 10 * minHeapSize) {\n      // There are many old values in one of heaps. We nned to get rid of them\n      // to not use too avoid memory leaks\n      this.$IntegerBufferSet_recreateHeaps();\n    }\n  };\n\n  IntegerBufferSet.prototype.$IntegerBufferSet_recreateHeaps=function() {\n    var sourceHeap = this.$IntegerBufferSet_smallValues.size() < this.$IntegerBufferSet_largeValues.size() ?\n      this.$IntegerBufferSet_smallValues :\n      this.$IntegerBufferSet_largeValues;\n    var newSmallValues = new Heap(\n      [], // Initial data in the heap\n      this.$IntegerBufferSet_smallerComparator\n    );\n    var newLargeValues = new Heap(\n      [], // Initial datat in the heap\n      this.$IntegerBufferSet_greaterComparator\n    );\n    while (!sourceHeap.empty()) {\n      var element = sourceHeap.pop();\n      // Push all stil valid elements to new heaps\n      if (this.$IntegerBufferSet_valueToPositionMap[element.value] !== undefined) {\n        newSmallValues.push(element);\n        newLargeValues.push(element);\n      }\n    }\n    this.$IntegerBufferSet_smallValues = newSmallValues;\n    this.$IntegerBufferSet_largeValues = newLargeValues;\n  };\n\n  IntegerBufferSet.prototype.$IntegerBufferSet_cleanHeap=function(heap) {\n    while (!heap.empty() &&\n        this.$IntegerBufferSet_valueToPositionMap[heap.peek().value] === undefined) {\n      heap.pop();\n    }\n  };\n\n  IntegerBufferSet.prototype.$IntegerBufferSet_smallerComparator=function(lhs, /*object*/ rhs)  {\n    return lhs.value < rhs.value;\n  };\n\n  IntegerBufferSet.prototype.$IntegerBufferSet_greaterComparator=function(lhs, /*object*/ rhs)  {\n    return lhs.value > rhs.value;\n  };\n\n\n\nmodule.exports = IntegerBufferSet;\n"]}