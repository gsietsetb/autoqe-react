{"version":3,"sources":["../../../../../../../../src/hoverMap/components/controls/fixed_table/fixed-data-table-ice/internal/PrefixIntervalTree.js"],"names":["PrefixIntervalTree","leafCount","initialLeafValue","internalLeafCount","getInternalLeafCount","$PrefixIntervalTree_leafCount","$PrefixIntervalTree_internalLeafCount","nodeCount","Int32Array","global","Array","$PrefixIntervalTree_value","$PrefixIntervalTree_initTables","get","bind","set","lowerBound","upperBound","prototype","firstLeaf","lastLeaf","i","lastInternalNode","position","value","nodeIndex","Math","floor","min","result","index","$PrefixIntervalTree_upperBoundImpl","previousValue","nodeIntervalBegin","nodeIntervalEnd","nodeIntervalMidpoint","module","exports"],"mappings":"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","file":"PrefixIntervalTree.js","sourcesContent":["/**\n * Copyright (c) 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PrefixIntervalTree\n * @typechecks\n */\n\n\"use strict\";\n\n/**\n * An interval tree that allows to set a number at index and given the value\n * find the largest index for which prefix sum is greater than or equal to value\n * (lower bound) or greater than value (upper bound)\n * Complexity:\n *   construct: O(n)\n *   query: O(log(n))\n *   memory: O(log(n)),\n * where n is leafCount from the constructor\n */\n\n  function PrefixIntervalTree(leafCount, /*?number*/ initialLeafValue) {\n    var internalLeafCount = this.getInternalLeafCount(leafCount);\n    this.$PrefixIntervalTree_leafCount = leafCount;\n    this.$PrefixIntervalTree_internalLeafCount = internalLeafCount;\n    var nodeCount = 2 * internalLeafCount;\n    var Int32Array = global.Int32Array || Array;\n    this.$PrefixIntervalTree_value = new Int32Array(nodeCount);\n    this.$PrefixIntervalTree_initTables(initialLeafValue || 0);\n\n    this.get = this.get.bind(this);\n    this.set = this.set.bind(this);\n    this.lowerBound = this.lowerBound.bind(this);\n    this.upperBound = this.upperBound.bind(this);\n  }\n\n  PrefixIntervalTree.prototype.getInternalLeafCount=function(leafCount)  {\n    var internalLeafCount = 1;\n    while (internalLeafCount < leafCount) {\n      internalLeafCount *= 2;\n    }\n    return internalLeafCount;\n  };\n\n  PrefixIntervalTree.prototype.$PrefixIntervalTree_initTables=function(initialLeafValue) {\n    var firstLeaf = this.$PrefixIntervalTree_internalLeafCount;\n    var lastLeaf = this.$PrefixIntervalTree_internalLeafCount + this.$PrefixIntervalTree_leafCount - 1;\n    var i;\n    for (i = firstLeaf; i <= lastLeaf; ++i) {\n      this.$PrefixIntervalTree_value[i] = initialLeafValue;\n    }\n    var lastInternalNode = this.$PrefixIntervalTree_internalLeafCount - 1;\n    for (i = lastInternalNode; i > 0; --i) {\n      this.$PrefixIntervalTree_value[i] =  this.$PrefixIntervalTree_value[2 * i] + this.$PrefixIntervalTree_value[2 * i + 1];\n    }\n  };\n\n  PrefixIntervalTree.prototype.set=function(position, /*number*/ value) {\n    var nodeIndex = position + this.$PrefixIntervalTree_internalLeafCount;\n    this.$PrefixIntervalTree_value[nodeIndex] = value;\n    nodeIndex = Math.floor(nodeIndex / 2);\n    while (nodeIndex !== 0) {\n      this.$PrefixIntervalTree_value[nodeIndex] =\n        this.$PrefixIntervalTree_value[2 * nodeIndex] + this.$PrefixIntervalTree_value[2 * nodeIndex + 1];\n      nodeIndex = Math.floor(nodeIndex / 2);\n    }\n  };\n\n  /**\n   * Returns an object {index, value} for given position (including value at\n   * specified position), or the same for last position if provided position\n   * is out of range\n   */\n  PrefixIntervalTree.prototype.get=function(position)  {\n    position = Math.min(position, this.$PrefixIntervalTree_leafCount);\n    var nodeIndex = position + this.$PrefixIntervalTree_internalLeafCount;\n    var result = this.$PrefixIntervalTree_value[nodeIndex];\n    while (nodeIndex > 1) {\n      if (nodeIndex % 2 === 1) {\n        result = this.$PrefixIntervalTree_value[nodeIndex - 1] + result;\n      }\n      nodeIndex = Math.floor(nodeIndex / 2);\n    }\n    return {index: position, value: result};\n  };\n\n  /**\n   * Returns an object {index, value} where index is index of leaf that was\n   * found by upper bound algorithm. Upper bound finds first element for which\n   * value is greater than argument\n   */\n  PrefixIntervalTree.prototype.upperBound=function(value)  {\n    var result = this.$PrefixIntervalTree_upperBoundImpl(1, 0, this.$PrefixIntervalTree_internalLeafCount - 1, value);\n    if (result.index > this.$PrefixIntervalTree_leafCount - 1) {\n      result.index = this.$PrefixIntervalTree_leafCount - 1;\n    }\n    return result;\n  };\n\n  /**\n   * Returns result in the same format as upperBound, but finds first element\n   * for which value is greater than or equal to argument\n   */\n  PrefixIntervalTree.prototype.lowerBound=function(value)  {\n    var result = this.upperBound(value);\n    if (result.value > value && result.index > 0) {\n      var previousValue =\n        result.value - this.$PrefixIntervalTree_value[this.$PrefixIntervalTree_internalLeafCount + result.index];\n      if (previousValue === value) {\n        result.value = previousValue;\n        result.index--;\n      }\n    }\n    return result;\n  };\n\n  PrefixIntervalTree.prototype.$PrefixIntervalTree_upperBoundImpl=function(\nnodeIndex,\n    /*number*/ nodeIntervalBegin,\n    /*number*/ nodeIntervalEnd,\n    /*number*/ value)\n    {\n    if (nodeIntervalBegin === nodeIntervalEnd) {\n      return {\n        index: nodeIndex - this.$PrefixIntervalTree_internalLeafCount,\n        value: this.$PrefixIntervalTree_value[nodeIndex],\n      };\n    }\n\n    var nodeIntervalMidpoint =\n      Math.floor((nodeIntervalBegin + nodeIntervalEnd + 1) / 2);\n    if (value < this.$PrefixIntervalTree_value[nodeIndex * 2]) {\n      return this.$PrefixIntervalTree_upperBoundImpl(\n        2 * nodeIndex,\n        nodeIntervalBegin,\n        nodeIntervalMidpoint - 1,\n        value\n      );\n    } else {\n      var result = this.$PrefixIntervalTree_upperBoundImpl(\n        2 * nodeIndex + 1,\n        nodeIntervalMidpoint,\n        nodeIntervalEnd,\n        value - this.$PrefixIntervalTree_value[2 * nodeIndex]\n      );\n      result.value += this.$PrefixIntervalTree_value[2 * nodeIndex];\n      return result;\n    }\n  };\n\n\nmodule.exports = PrefixIntervalTree;\n"]}