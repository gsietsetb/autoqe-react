{"version":3,"sources":["../../../../../src/hoverMap/utils/math/bezier.js"],"names":["Coordinate","require","lerp","a","b","x","Bezier","x0","y0","x1","y1","x2","y2","x3","y3","KAPPA","Math","sqrt","prototype","clone","equals","other","flip","temp","getPointX","t","ix0","ix1","ix2","getPointY","iy0","iy1","iy2","getPoint","subdivideLeft","subdivideRight","subdivide","s","solvePositionFromXValue","xVal","epsilon","tMin","tMax","i","value","derivative","abs","solveYValueFromXValue","module","exports"],"mappings":"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","file":"bezier.js","sourcesContent":["// Copyright 2007 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n/**\n * @fileoverview Represents a cubic Bezier curve.\n *\n * Uses the deCasteljau algorithm to compute points on the curve.\n * http://en.wikipedia.org/wiki/De_Casteljau's_algorithm\n *\n * Currently it uses an unrolled version of the algorithm for speed.  Eventually\n * it may be useful to use the loop form of the algorithm in order to support\n * curves of arbitrary degree.\n *\n * @author robbyw@google.com (Robby Walker)\n */\n\n\nvar Coordinate = require('./coordinate.js');\n\nvar lerp = function(a, b, x) {\n  return a + x * (b - a);\n};\n\n\n/**\n * Object representing a cubic bezier curve.\n * @param {number} x0 X coordinate of the start point.\n * @param {number} y0 Y coordinate of the start point.\n * @param {number} x1 X coordinate of the first control point.\n * @param {number} y1 Y coordinate of the first control point.\n * @param {number} x2 X coordinate of the second control point.\n * @param {number} y2 Y coordinate of the second control point.\n * @param {number} x3 X coordinate of the end point.\n * @param {number} y3 Y coordinate of the end point.\n * @struct\n * @constructor\n * @final\n */\nvar Bezier = function(x0, y0, x1, y1, x2, y2, x3, y3) {\n  /**\n   * X coordinate of the first point.\n   * @type {number}\n   */\n  this.x0 = x0;\n\n  /**\n   * Y coordinate of the first point.\n   * @type {number}\n   */\n  this.y0 = y0;\n\n  /**\n   * X coordinate of the first control point.\n   * @type {number}\n   */\n  this.x1 = x1;\n\n  /**\n   * Y coordinate of the first control point.\n   * @type {number}\n   */\n  this.y1 = y1;\n\n  /**\n   * X coordinate of the second control point.\n   * @type {number}\n   */\n  this.x2 = x2;\n\n  /**\n   * Y coordinate of the second control point.\n   * @type {number}\n   */\n  this.y2 = y2;\n\n  /**\n   * X coordinate of the end point.\n   * @type {number}\n   */\n  this.x3 = x3;\n\n  /**\n   * Y coordinate of the end point.\n   * @type {number}\n   */\n  this.y3 = y3;\n};\n\n\n/**\n * Constant used to approximate ellipses.\n * See: http://canvaspaint.org/blog/2006/12/ellipse/\n * @type {number}\n */\nBezier.KAPPA = 4 * (Math.sqrt(2) - 1) / 3;\n\n\n/**\n * @return {!Bezier} A copy of this curve.\n */\nBezier.prototype.clone = function() {\n  return new Bezier(this.x0, this.y0, this.x1, this.y1, this.x2,\n      this.y2, this.x3, this.y3);\n};\n\n\n/**\n * Test if the given curve is exactly the same as this one.\n * @param {Bezier} other The other curve.\n * @return {boolean} Whether the given curve is the same as this one.\n */\nBezier.prototype.equals = function(other) {\n  return this.x0 == other.x0 && this.y0 == other.y0 && this.x1 == other.x1 &&\n         this.y1 == other.y1 && this.x2 == other.x2 && this.y2 == other.y2 &&\n         this.x3 == other.x3 && this.y3 == other.y3;\n};\n\n\n/**\n * Modifies the curve in place to progress in the opposite direction.\n */\nBezier.prototype.flip = function() {\n  var temp = this.x0;\n  this.x0 = this.x3;\n  this.x3 = temp;\n  temp = this.y0;\n  this.y0 = this.y3;\n  this.y3 = temp;\n\n  temp = this.x1;\n  this.x1 = this.x2;\n  this.x2 = temp;\n  temp = this.y1;\n  this.y1 = this.y2;\n  this.y2 = temp;\n};\n\n\n/**\n * Computes the curve's X coordinate at a point between 0 and 1.\n * @param {number} t The point on the curve to find.\n * @return {number} The computed coordinate.\n */\nBezier.prototype.getPointX = function(t) {\n  // Special case start and end.\n  if (t == 0) {\n    return this.x0;\n  } else if (t == 1) {\n    return this.x3;\n  }\n\n  // Step one - from 4 points to 3\n  var ix0 = lerp(this.x0, this.x1, t);\n  var ix1 = lerp(this.x1, this.x2, t);\n  var ix2 = lerp(this.x2, this.x3, t);\n\n  // Step two - from 3 points to 2\n  ix0 = lerp(ix0, ix1, t);\n  ix1 = lerp(ix1, ix2, t);\n\n  // Final step - last point\n  return lerp(ix0, ix1, t);\n};\n\n\n/**\n * Computes the curve's Y coordinate at a point between 0 and 1.\n * @param {number} t The point on the curve to find.\n * @return {number} The computed coordinate.\n */\nBezier.prototype.getPointY = function(t) {\n  // Special case start and end.\n  if (t == 0) {\n    return this.y0;\n  } else if (t == 1) {\n    return this.y3;\n  }\n\n  // Step one - from 4 points to 3\n  var iy0 = lerp(this.y0, this.y1, t);\n  var iy1 = lerp(this.y1, this.y2, t);\n  var iy2 = lerp(this.y2, this.y3, t);\n\n  // Step two - from 3 points to 2\n  iy0 = lerp(iy0, iy1, t);\n  iy1 = lerp(iy1, iy2, t);\n\n  // Final step - last point\n  return lerp(iy0, iy1, t);\n};\n\n\n/**\n * Computes the curve at a point between 0 and 1.\n * @param {number} t The point on the curve to find.\n * @return {!Coordinate} The computed coordinate.\n */\nBezier.prototype.getPoint = function(t) {\n  return new Coordinate(this.getPointX(t), this.getPointY(t));\n};\n\n\n/**\n * Changes this curve in place to be the portion of itself from [t, 1].\n * @param {number} t The start of the desired portion of the curve.\n */\nBezier.prototype.subdivideLeft = function(t) {\n  if (t == 1) {\n    return;\n  }\n\n  // Step one - from 4 points to 3\n  var ix0 = lerp(this.x0, this.x1, t);\n  var iy0 = lerp(this.y0, this.y1, t);\n\n  var ix1 = lerp(this.x1, this.x2, t);\n  var iy1 = lerp(this.y1, this.y2, t);\n\n  var ix2 = lerp(this.x2, this.x3, t);\n  var iy2 = lerp(this.y2, this.y3, t);\n\n  // Collect our new x1 and y1\n  this.x1 = ix0;\n  this.y1 = iy0;\n\n  // Step two - from 3 points to 2\n  ix0 = lerp(ix0, ix1, t);\n  iy0 = lerp(iy0, iy1, t);\n\n  ix1 = lerp(ix1, ix2, t);\n  iy1 = lerp(iy1, iy2, t);\n\n  // Collect our new x2 and y2\n  this.x2 = ix0;\n  this.y2 = iy0;\n\n  // Final step - last point\n  this.x3 = lerp(ix0, ix1, t);\n  this.y3 = lerp(iy0, iy1, t);\n};\n\n\n/**\n * Changes this curve in place to be the portion of itself from [0, t].\n * @param {number} t The end of the desired portion of the curve.\n */\nBezier.prototype.subdivideRight = function(t) {\n  this.flip();\n  this.subdivideLeft(1 - t);\n  this.flip();\n};\n\n\n/**\n * Changes this curve in place to be the portion of itself from [s, t].\n * @param {number} s The start of the desired portion of the curve.\n * @param {number} t The end of the desired portion of the curve.\n */\nBezier.prototype.subdivide = function(s, t) {\n  this.subdivideRight(s);\n  this.subdivideLeft((t - s) / (1 - s));\n};\n\n\n/**\n * Computes the position t of a point on the curve given its x coordinate.\n * That is, for an input xVal, finds t s.t. getPointX(t) = xVal.\n * As such, the following should always be true up to some small epsilon:\n * t ~ solvePositionFromXValue(getPointX(t)) for t in [0, 1].\n * @param {number} xVal The x coordinate of the point to find on the curve.\n * @return {number} The position t.\n */\nBezier.prototype.solvePositionFromXValue = function(xVal) {\n  // Desired precision on the computation.\n  var epsilon = 1e-6;\n\n  // Initial estimate of t using linear interpolation.\n  var t = (xVal - this.x0) / (this.x3 - this.x0);\n  if (t <= 0) {\n    return 0;\n  } else if (t >= 1) {\n    return 1;\n  }\n\n  // Try gradient descent to solve for t. If it works, it is very fast.\n  var tMin = 0;\n  var tMax = 1;\n  for (var i = 0; i < 8; i++) {\n    var value = this.getPointX(t);\n    var derivative = (this.getPointX(t + epsilon) - value) / epsilon;\n    if (Math.abs(value - xVal) < epsilon) {\n      return t;\n    } else if (Math.abs(derivative) < epsilon) {\n      break;\n    } else {\n      if (value < xVal) {\n        tMin = t;\n      } else {\n        tMax = t;\n      }\n      t -= (value - xVal) / derivative;\n    }\n  }\n\n  // If the gradient descent got stuck in a local minimum, e.g. because\n  // the derivative was close to 0, use a Dichotomy refinement instead.\n  // We limit the number of interations to 8.\n  for (var i = 0; Math.abs(value - xVal) > epsilon && i < 8; i++) {\n    if (value < xVal) {\n      tMin = t;\n      t = (t + tMax) / 2;\n    } else {\n      tMax = t;\n      t = (t + tMin) / 2;\n    }\n    value = this.getPointX(t);\n  }\n  return t;\n};\n\n\n/**\n * Computes the y coordinate of a point on the curve given its x coordinate.\n * @param {number} xVal The x coordinate of the point on the curve.\n * @return {number} The y coordinate of the point on the curve.\n */\nBezier.prototype.solveYValueFromXValue = function(xVal) {\n  return this.getPointY(this.solvePositionFromXValue(xVal));\n};\n\n\nmodule.exports = Bezier;\n\n\n\n"]}